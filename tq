[1mdiff --git a/rst_files/fundamental_types.rst b/rst_files/fundamental_types.rst[m
[1mindex dbdd41a..465e7a7 100644[m
[1m--- a/rst_files/fundamental_types.rst[m
[1m+++ b/rst_files/fundamental_types.rst[m
[36m@@ -1062,6 +1062,8 @@[m [mThere are two distinct use cases for this[m
 #. ``nothing`` ("software engineers null"): used where no value makes sense in a particular context due to a failure in the code, a function parameter not passed in, etc.[m
 #. ``missing`` ("data scientists null"): used when a value would make conceptual sense, but it isn't available [m
 [m
[32m+[m[32m.. error_handling:[m
[32m+[m
 Nothing and Basic Error Handling[m
 ----------------------------------[m
 [m
[1mdiff --git a/rst_files/generic_programming.rst b/rst_files/generic_programming.rst[m
[1mindex 555d066..aece5ea 100644[m
[1m--- a/rst_files/generic_programming.rst[m
[1m+++ b/rst_files/generic_programming.rst[m
[36m@@ -256,75 +256,6 @@[m [mWe can likewise build specialized methods and hence generate fast code[m
 We'll see how this enables Julia to easily generate highly efficient machine code in :doc:`later on <need_for_speed>`[m
 [m
 [m
[31m-The Type Hierarchy[m
[31m-=====================[m
[31m-[m
[31m-Let's discuss how types are organized in Julia[m
[31m-[m
[31m-[m
[31m-Abstract vs Concrete Types[m
[31m----------------------------[m
[31m-[m
[31m-We saw above that ``Float64`` is the standard type for representing a 64 bit[m
[31m-floating point number[m
[31m-[m
[31m-But we've also seen references to types such as ``Real`` and ``AbstractFloat``[m
[31m-[m
[31m-The former (i.e., ``Float64``) is an example of a **concrete type**, as is ``Int64`` or ``Float32``[m
[31m-[m
[31m-The latter (i.e., ``Real``, ``AbstractFloat``) are examples of so-called **abstract types**[m
[31m-[m
[31m-Concrete types are types that we can *instantiate* --- i.e., pair with data in memory[m
[31m-[m
[31m-On the other hand, abstract types help us organize and work with related concrete types[m
[31m-[m
[31m-[m
[31m-The Type Hierarchy[m
[31m-----------------------[m
[31m-[m
[31m-How exactly do abstract types organize or relate different concrete types?[m
[31m-[m
[31m-The answer is that, in the Julia language specification, the types form a hierarchy[m
[31m-[m
[31m-For example, ``Float64`` and ``Int64`` are **subtypes** of ``Real``[m
[31m-[m
[31m-.. code-block:: julia[m
[31m-[m
[31m-    Float64 <: Real[m
[31m-[m
[31m-.. code-block:: julia[m
[31m-[m
[31m-    Int64 <: Real[m
[31m-[m
[31m-[m
[31m-On the other hand, 64 bit complex numbers are not reals[m
[31m-[m
[31m-.. code-block:: julia[m
[31m-[m
[31m-    ComplexF32 <: Real[m
[31m-[m
[31m-[m
[31m-They are, however, subtypes of ``Number``[m
[31m-[m
[31m-.. code-block:: julia[m
[31m-[m
[31m-    ComplexF32 <: Number[m
[31m-[m
[31m-[m
[31m-``Number`` in turn is a subtype of ``Any``, which is a parent of all types[m
[31m-[m
[31m-[m
[31m-.. code-block:: julia[m
[31m-[m
[31m-    Number <: Any[m
[31m-[m
[31m-[m
[31m-In particular, the type tree is organized with ``Any`` at the top and the concrete types at the bottom[m
[31m-[m
[31m-[m
[31m-We never actually see *instances* of abstract types (i.e., ``typeof(x)`` never returns an abstract type)[m
[31m-[m
[31m-The point of abstract types is to categorize the concrete types, as well as other abstract types that sit below them in the hierarchy[m
 [m
 [m
 Back to Multiple Dispatch[m
[1mdiff --git a/rst_files/introduction_to_types.rst b/rst_files/introduction_to_types.rst[m
[1mindex 5bd169a..fd43d99 100644[m
[1m--- a/rst_files/introduction_to_types.rst[m
[1m+++ b/rst_files/introduction_to_types.rst[m
[36m@@ -11,7 +11,7 @@[m [mIntroduction to Types and Generic Programming[m
 Overview[m
 ============================[m
 [m
[31m-In Julia, arrays and tuples are the most important data type sfor working with numerical data[m
[32m+[m[32mIn Julia, arrays and tuples are the most important data type for working with numerical data[m
 [m
 In this lecture we give more details on[m
 [m
[36m@@ -26,6 +26,14 @@[m [mSetup[m
 [m
 .. literalinclude:: /_static/includes/deps.jl[m
 [m
[32m+[m[32m<<<<<<< HEAD[m
[32m+[m[32m=======[m
[32m+[m[32m.. code-block:: julia[m
[32m+[m
[32m+[m[32m    using InstantiateFromURL[m
[32m+[m[32m    activate_github("QuantEcon/QuantEconLecturePackages", tag="v0.3.1")[m
[32m+[m[32m    using LinearAlgebra, Statistics, Compat[m
[32m+[m[32m>>>>>>> d5cba6c... Type hiearchy merged[m
 [m
 Finding and Interpreting Types[m
 ================================[m
[36m@@ -60,7 +68,7 @@[m [mThe next two types use curly bracket notation to express the fact that they are[m
     @show typeof(1.0 + 1im)[m
     @show typeof(ones(2,2));[m
 [m
[31m-We will learn more details about  :doc:`generic programming <generic_programming>` later, but the key is to interpret the curly brackets as swappable parameters for a given type[m
[32m+[m[32mWe will learn more details about :doc:`generic programming <generic_programming>` later, but the key is to interpret the curly brackets as swappable parameters for a given type[m
 [m
 For example, ``Array{Float64, 2}`` can be read as[m
 [m
[36m@@ -77,8 +85,6 @@[m [mIn the case of ``Complex{Float64}``[m
 #. ``Complex`` is an abstract complex number type[m
 #. ``Float64`` is a concrete type declaring what the type of the real and imaginary parts of the value should store[m
 [m
[31m-We will see later that both the ``Array``and ``Complex`` require that any type it uses for storage is a ``Real``--which ``Float64`` fulfills[m
[31m-[m
 Another type to consider is the ``Tuple`` and ``Named Tuple``[m
 [m
 .. code-block:: julia[m
[36m@@ -97,23 +103,23 @@[m [mFor a named tuple[m
 [m
 The parametric ``NamedTuple`` type contains 2 parameters: first a list of names for each field of the tuple, and second the underlying ``Tuple`` type to store the values[m
 [m
[31m-Anytime a value is prefixed by a colon, as in the ``:a`` above, the type is ``Symbol``--a special kind of string used to make the code general and high-performance[m
[32m+[m[32mAnytime a value is prefixed by a colon, as in the ``:a`` above, the type is ``Symbol``--a special kind of string used by the compiler[m
 [m
 .. code-block:: julia[m
 [m
     typeof(:a)[m
 [m
 [m
[31m-See `julia documentation <https://docs.julialang.org/en/v1/manual/types/#Parametric-Types-1>`_ for more on parametric types[m
[32m+[m[32m(See `parametric types documentation <https://docs.julialang.org/en/v1/manual/types/#Parametric-Types-1>`_)[m
[32m+[m
[32m+[m[32m**Remark:** Note that, by convention, type names use CamelCase ---  ``FloatingPoint``, ``Array``, ``AbstractArray``, etc.[m
 [m
[31m-**Remark:** Note that, by convention, type names use CamelCase ---  ``FloatingPoint``, ``Array``, ``AbstractArray``, etc.    [m
 [m
 Variables, Types, and Values[m
 --------------------------------[m
 [m
 Since variables and functions are denoted in lower case, this can be used to easily identify types when reading code and output[m
 [m
[31m-[m
 After assigning a variable name to an value, we can query the type of the[m
 value via the name[m
 [m
[36m@@ -139,8 +145,85 @@[m [mNow ``x`` "points to" another value, of type ``Float64``[m
 [m
     typeof(x)[m
 [m
[31m-Deducing Types[m
[31m-======================[m
[32m+[m[32mHowever, outside of these sorts of examples and tests, it is usually a bad idea to change the type of a variable haphazardly[m
[32m+[m
[32m+[m[32mBeyond a few notable exceptions for error handling (e.g. ``nothing`` used for `error handling <error_handling>`_), changing types is usually a symptom of poorly organized code--and it makes compiler `type inference <type_inference>`_ more difficult[m
[32m+[m
[32m+[m[32mThe Type Hierarchy[m
[32m+[m[32m=====================[m
[32m+[m
[32m+[m[32mLet's discuss how types are organized in Julia[m
[32m+[m
[32m+[m[32mAbstract vs Concrete Types[m
[32m+[m[32m---------------------------[m
[32m+[m[32m(See `abstract types documentation  <https://docs.julialang.org/en/v1/manual/types/#Abstract-Types-1>`_)[m
[32m+[m
[32m+[m[32mIn our example above, the Julia library code for ``Array``and ``Complex`` are written in a way such that it will work for any ``Real`` type--which ``Float64`` fulfills[m
[32m+[m
[32m+[m[32mIn this case, ``Real`` is an **abstract type**, and a value of type ``Real`` can never be created directly[m[41m [m
[32m+[m
[32m+[m[32mInstead, it provides a way to write :doc:`generic <generic_programming>` code for specific to any concrete types based on ``Real``[m
[32m+[m
[32m+[m[32mWe saw above that ``Float64`` is the standard type for representing a 64 bit[m
[32m+[m[32mfloating point number[m
[32m+[m
[32m+[m[32mBut we've also seen references to types such as ``Real`` and ``AbstractFloat``[m
[32m+[m
[32m+[m[32mThe former (i.e., ``Float64``) is an example of a **concrete type**, as is ``Int64`` or ``Float32``[m
[32m+[m
[32m+[m[32mThe latter (i.e., ``Real``, ``AbstractFloat``) are examples of so-called **abstract types**[m
[32m+[m
[32m+[m[32mConcrete types are types that we can *instantiate* --- i.e., pair with data in memory[m
[32m+[m
[32m+[m[32mOn the other hand, abstract types help us organize and work with related concrete types[m
[32m+[m
[32m+[m
[32m+[m[32mThe Type Hierarchy[m
[32m+[m[32m----------------------[m
[32m+[m
[32m+[m[32mHow exactly do abstract types organize or relate different concrete types?[m
[32m+[m
[32m+[m[32mThe answer is that, in the Julia language specification, the types form a hierarchy[m
[32m+[m
[32m+[m[32mYou can check if a type is a subtype of another with the ``<:`` operator[m
[32m+[m
[32m+[m[32m.. code-block:: julia[m
[32m+[m
[32m+[m[32m    @show Float64 <: Real[m
[32m+[m[32m    @show Int64 <: Real[m
[32m+[m[32m    @show Complex{Float64} <: Real[m
[32m+[m[32m    @show Array <: Real;[m
[32m+[m
[32m+[m[32mIn the above, both ``Float64`` and ``Int64`` are **subtypes** of ``Real``, whereas the ``Complex`` numbers are not[m
[32m+[m
[32m+[m[32mThey are, however, all subtypes of ``Number``[m
[32m+[m
[32m+[m[32m.. code-block:: julia[m
[32m+[m
[32m+[m[32m    @show Real <: Number[m
[32m+[m[32m    @show Float64 <: Number[m
[32m+[m[32m    @show Int64 <: Number[m
[32m+[m[32m    @show Complex{Float64} <: Number;[m
[32m+[m
[32m+[m
[32m+[m[32m``Number`` in turn is a subtype of ``Any``, which is a parent of all types[m
[32m+[m
[32m+[m
[32m+[m[32m.. code-block:: julia[m
[32m+[m
[32m+[m[32m    Number <: Any[m
[32m+[m
[32m+[m
[32m+[m[32mIn particular, the type tree is organized with ``Any`` at the top and the concrete types at the bottom[m
[32m+[m
[32m+[m[32mWe never actually see *instances* of abstract types (i.e., ``typeof(x)`` never returns an abstract type)[m
[32m+[m
[32m+[m[32mThe point of abstract types is to categorize the concrete types, as well as other abstract types that sit below them in the hierarchy[m
[32m+[m
[32m+[m[32m.. _type_inference:[m
[32m+[m
[32m+[m[32mDeducing and Declaring Types[m
[32m+[m[32m=============================[m
 [m
 We will discuss this in detail in :doc:`this lecture <generic_programming>`, but much of its performance gains and generality of notation comes from Julia's type system[m
 [m
[36m@@ -175,9 +258,11 @@[m [mWe will discuss this in more detail in :doc:`this lecture <need_for_speed>`, but[m
 [m
 .. code-block:: julia[m
 [m
[32m+[m[32m    x = [1, 2, 3][m
[32m+[m[32m    f(x) = 2x[m
     @code_warntype f(x)[m
 [m
[31m-Here, the ``Body::Array{Int64,1}`` tells us the type of the return value of the function is a simple vector[m
[32m+[m[32mHere, the ``Body::Array{Int64,1}`` tells us the type of the return value of the function when called with ``[1, 2, 3]`` is always a vector of integers[m
 [m
 In contrast, consider a function potentially returning ``nothing``, as in :doc:`this lecture <fundamental_types>`[m
 [m
[36m@@ -232,18 +317,18 @@[m [mLuckily, the practice of trying to ensure that functions return the same types i[m
 Manually Declaring Types[m
 -------------------------[m
 [m
[31m-While we keep talking about types, you will notice that we have never declared any types in the underlying code[m
[32m+[m[32mYou will notice that in the lecture notes we have never directly declared any types[m
 [m
[31m-This is intentional for exposition and "user" code of packages, rather than the writing of those packages themselves[m
[32m+[m[32mThis is intentional for exposition and for serious "user" code of packages, rather than the writing of those packages themselves[m
 [m
[31m-It is also in contrast to some of the sample code you will see in other julia sources[m
[32m+[m[32mIt is also in contrast to some of the sample code you will see in other Julia sources, which you will need to be able to read[m
 [m
 To give an example of the declaration of types, the following are equivalent[m
 [m
 .. code-block:: julia[m
 [m
     function f(x, A)[m
[31m-        b = [5.0; 6.0][m
[32m+[m[32m        b = [5.0, 6.0][m
         return A * x .+ b[m
     end[m
     val = f([0.1, 2.0], [1.0 2.0; 3.0 4.0])[m
[36m@@ -251,7 +336,7 @@[m [mTo give an example of the declaration of types, the following are equivalent[m
 .. code-block:: julia[m
 [m
     function f2(x::Vector{Float64}, A::Matrix{Float64})::Vector{Float64} # argument and return types[m
[31m-        b::Vector{Float64} = [5.0; 6.0][m
[32m+[m[32m        b::Vector{Float64} = [5.0, 6.0][m
         return A * x .+ b[m
     end[m
     val = f2([0.1; 2.0], [1.0 2.0; 3.0 4.0])[m
[36m@@ -277,5 +362,14 @@[m [mDeclaring Struct[m
 [m
 TODO: Another major diff[m
 [m
[32m+[m
[32m+[m[32mMultiple Dispatch[m
[32m+[m[32m==================[m
[32m+[m[32muse abs for numbers and complex numbers[m
[32m+[m
[32m+[m[32mspecial code for trapezoidal rule for a uniform vs. non-uniform grid[m
[32m+[m
 Exercises[m
 =============[m
[32m+[m
[32m+[m[32mImplement the trap for both[m
\ No newline at end of file[m
[1mdiff --git a/style.md b/style.md[m
[1mindex 5b35c5b..57af315 100644[m
[1m--- a/style.md[m
[1m+++ b/style.md[m
[36m@@ -214,6 +214,14 @@[m [mA = zeros(N,N)[m
 y = similar(x, N) # keeps things generic.  The `N` here is not required if the same size[m
 A = similar(x, N, N) # same type but NxN size[m
 ```[m
[32m+[m[32m- **Create vector literals with `,`** rather than `;` when possible[m
[32m+[m[32m```julia[m
[32m+[m[32m# BAD![m
[32m+[m[32my = [1; 2; 3][m
[32m+[m
[32m+[m[32m# GOOD![m
[32m+[m[32my = [1, 2, 3][m
[32m+[m[32m```[m
 - **Leave matrix/vector types as returned types as long as possible**.  That is, avoid `Matrix(...)` just for conversion, leaving multiple-dispatch to do its job.[m
 ```julia[m
 x = [1 0; 0 1][m
